#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
nix-flake-grep - search all resolved inputs of a flake with ripgrep

Usage:
  nix-flake-grep [--flake <path-or-ref>] -- <ripgrep-args...>
  nix-flake-grep [pattern] [ripgrep-args...]

Examples:
  nix-flake-grep foobar
  nix-flake-grep --flake github:numtide/blueprint -- foobar -g '*.nix'

Options:
  -f, --flake   Flake reference to inspect (defaults to '.')
  -h, --help    Show this help message

All arguments after '--' (or any argument not parsed above) are forwarded to ripgrep.
EOF
}

flake="."
declare -a rg_args=()

while (($# > 0)); do
  case "$1" in
    -f|--flake)
      if (($# == 1)); then
        echo "error: missing value for $1" >&2
        exit 2
      fi
      flake="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      rg_args+=("$@")
      break
      ;;
    *)
      rg_args+=("$1")
      shift
      ;;
  esac
done

if ((${#rg_args[@]} == 0)); then
  echo "error: provide at least one ripgrep argument (for example, a pattern)" >&2
  echo >&2
  usage >&2
  exit 2
fi

readarray -t inputs < <(
  nix --extra-experimental-features 'nix-command flakes' \
    flake archive --json --no-write-lock-file "$flake" \
    | jq -r '
        def append_name($prefix; $suffix):
          if $prefix == "" then $suffix
          elif $prefix == "self" then $suffix
          else $prefix + "/" + $suffix
          end;

        def listInputs($prefix):
          (
            if has("path") and (.path != null) then
              [{ name: $prefix, path: .path }]
            else
              []
            end
          )
          + (
            .inputs // {}
            | to_entries
            | reduce .[] as $child ([]; . + ($child.value | listInputs(append_name($prefix; $child.key))))
          );

        listInputs("self")[]
        | select(.path != null)
        | "\(.name)\t\(.path)"
      '
)

if ((${#inputs[@]} == 0)); then
  echo "error: unable to resolve flake inputs for '$flake'" >&2
  exit 1
fi

declare -A seen_paths=()
any_match=0

declare -a rg_command_args=("${rg_args[@]}")
if [[ -t 1 && -z ${NO_COLOR:-} ]]; then
  has_color_flag=0
  for arg in "${rg_args[@]}"; do
    case "$arg" in
      --color*|--no-color)
        has_color_flag=1
        break
        ;;
    esac
  done
  if [[ $has_color_flag -eq 0 ]]; then
    rg_command_args+=("--color=always")
  fi
fi

for entry in "${inputs[@]}"; do
  name="${entry%%$'\t'*}"
  path="${entry#*$'\t'}"

  [[ -n "$name" && -n "$path" ]] || continue

  if [[ -n "${seen_paths[$path]:-}" ]]; then
    continue
  fi
  seen_paths["$path"]=1

  if [[ ! -d "$path" ]]; then
    echo "warning: skipping $name ($path) because it is not a directory" >&2
    continue
  fi

  set +e
  rg "${rg_command_args[@]}" "$path" | while IFS= read -r line; do
    printf '[%s] %s\n' "$name" "$line"
  done
  status=${PIPESTATUS[0]}
  set -e

  case "$status" in
    0)
      any_match=1
      ;;
    1)
      ;;
    *)
      exit "$status"
      ;;
  esac
done

if [[ $any_match -eq 0 ]]; then
  exit 1
fi
